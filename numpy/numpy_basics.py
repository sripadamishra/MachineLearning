# -*- coding: utf-8 -*-
"""Numpy_Basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ul7QU5PHFw3mSBOnJ1AEvSFQmoOU8CHx

#Numpy Tutorials
"""

# What is Numpy?
# This is the fundamental package of python scientific computing.
# It is a library to work with array ( It has ndarray object for efficient operation)
# Shoft form - Numerical Python
# This library provides a multidimensional array object,
# various derived objects (such as masked arrays and matrices).
# Many routines for fast operations on arrays, including mathematical, logical, shape manipulation,
# sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations,
# random simulation etc.

# Numpy operation are faster than traditional python operation
# due to vectorization and broadcasting support
# Numpy code is optimized using precompiled-C code behind the scenes.

"""# Array Creation"""

# Creating an array from list
import numpy as np
my_np_array_1D = np.array([1,2,3,4])
my_np_array_2D = np.array([[1,2],[3,4]])
my_np_array_3D = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])

print('This is 1D array')
print(my_np_array_1D)
print('This is 2D array')
print(my_np_array_2D)
print('This is 3D array')
print(my_np_array_3D)

# while numpy.array() is used, it is important to consider the dtype ( the datatype of the array object)
my_array_a = np.array([1,2,45678], dtype=np.int8) # considering type np.int8, 45678 is truncated. To get correct answer, use int64 or int32
my_array_b = np.array([1,2,3], dtype=np.int64)

new_arr = my_array_a + my_array_b
print(new_arr)

"""# Array indexing, slicing and iterations"""

#indexing

#slicing

"""#Create array from built-in methods

# numpy.arange
"""

# numpy.arange creates arrays with regularly incrementing values.

my_arr = np.arange(10) # similar to python range()
print(my_arr)

#mention data type of the elements in the array, also you can start starting value of the element
my_floats = np.arange(2.5, 10.5, dtype=float)

print(my_floats)

# you can mention the step size how element will get incresed or decreased
# only 10 elements with step 0.1
print('Step size = 0.1')
my_new_array = np.arange(1, 2, 0.1)
print(my_new_array)

print('Step size = 0.015')
my_new_array = np.arange(1, 2, 0.015) # see there are more elements generated with lower step size
print(my_new_array)

# See the fun - many more element
print('Step size = 0.0015')
my_new_array = np.arange(1, 2, 0.0015) # see there are more elements generated with lower step size
print(my_new_array)

"""# numpy.linspace"""

# This method also generates 1D array. you can mention the numder of elements generated with linespace(start,stop,no of elements)
x = np.linspace(4., 10., 6)
print(x)

"""# 2D array creation functions

#numpy.eye
"""

# np.eye(n, m) defines a 2D identity matrix.

# This creates an Identity matrix with the diagonal values are all 1 and rest are all 0s.
# for all i == j ( row == col ) positions, it puts 1 and rest are all 0s.
print('A 5x5 matrix')
x = np.eye(5)
print(x)

print('A 5x7 matrix')
# Similarly for n is not equal to m, it creates following matrix ( 2D array ) keeping all i == j as 1 and others are 0s.
xy = np.eye(5,7)
print(xy)

"""#numpy.diag"""

# it returns diagonal matrix
x = np.arange(1,10).reshape(3,3)
print('This is s 3x3 matrix')
print(x)

print('Print the diagonal')
print(np.diag(x))

# Now if you provide only the diagonal value as a 1D array, it will give you the 2D array keeping others as zero
m = np.diag(np.diag(x))
print('The matrix from 1D diagonal')
print(m)

"""# numpy.vander"""

# It defines a Vandermonde matrix as a 2D NumPy array.
# Each column of the Vandermonde matrix is a decreasing power of the input 1D array or list or tuple,
# x where the highest polynomial order is n-1

x = np.vander([1,2,3,4],2)
print(x)


x = np.vander([1,2,3,4],4)
print(x)

"""# General ndarray creation functions

#numpy.ones
"""

#numpy.ones will create an array filled with 1 values with the specified shape. The default dtype is float64.

print(np.ones((3,4)))

"""# numpy.zeros"""

#numpy.zeros will create an array filled with 0 values with the specified shape. The default dtype is float64.

print(np.zeros((3,4)))

"""#Numpy Array Copy and View"""

# Case:1
# Assignment does not copy the array data.

x = np.arange(1,21).reshape(4,5)
print(x)
y = x

print(id(x))
print(id(y))
print(x is y)

import numpy as np
# Function call also does not make copy as Python passes references of mutable objects. Let us see that.
def fun(param):
  print(id(param))
x = np.arange(1,21).reshape(4,5)
print(id(x))

fun(x)

"""# View does Shallow copy"""

x = np.arange(1,21).reshape(4,5)
y = x.view()
y[0,0]=123 # change in y changes x meaning they share the same data. y's data is owned by x.
print(x)

"""#Deep Copy"""

x = np.arange(1,21).reshape(4,5)
z = x.copy()

z[0,0] = 12345 # changing z does not change x as x does not share anything with z. Z holds a new copy - deep copy.
print(x)

"""#Array Manipulations -
#numpy.vstack
"""

#Stack arrays in sequence vertically (row wise).
row1 = np.array([1, 2, 3])
row2 = np.array([4, 5, 6])
matrix = np.vstack((row1,row2)) # take tuple as input so () is required.


print(matrix)

"""#numpy.hstack"""

#Stack arrays in sequence horizontally (column wise).
# This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis.
#1D array
col1 = np.array([1, 2, 3])
col2 = np.array([4, 5, 6])

matrix = np.hstack((col1,col2))
print(matrix)

#2D example
a1 = np.array([[1, 2, 3],[4,5,6]])
a2 = np.array([[7, 8, 9],[10,11,12]])

print('Horizontal Stack')
matrix_1 = np.hstack((a1,a2))
print(matrix_1)

print('Verticle Stack')
matrix_2 = np.vstack((a1,a2))
print(matrix_2)

"""#numpy.dstack"""

# Stack arrays in sequence depth wise (along third axis).
# It concatenates along the third axis after 2-D arrays of shape (M,N) have been reshaped to (M,N,1)
# and 1-D arrays of shape (N,) have been reshaped to (1,N,1)
# output 3D array
print('1D example')
a1 = np.array([1, 2, 3, 4, 5, 6])
a2 = np.array([7, 8, 9,10,11,12])

matrix_2_3D = np.dstack((a1,a2))
print(matrix_2_3D)

print('2D example')
a3 = np.array([[1, 2, 3],[4,5,6]])
a4 = np.array([[7, 8, 9],[10,11,12]])
matrix_2_3D = np.dstack((a3,a4))

print(matrix_2_3D)

"""#split and array_split"""

import numpy as np
#split - divides or splits into equal size sub array
# Split an array into multiple sub-arrays as views into array.
# numpy.split(ary, indices_or_sections, axis=0)
# indices_or_sections can be either int or 1-D array
x = np.arange(12.0)
y = np.split(x,3)
print(y)

# now, if you put indices as 1D array
y = np.split(x,[3,5,6])
print(y)

# array_split allows indices_or_sections to be an integer that does not equally divide the axis.
x = np.arange(12.0)
y = np.array_split(x,5) # it allows unequal subarray.
print(y)

#dsplit

x = np.arange(16.0).reshape(2,4,2)
print(x)

y = np.dsplit(x,2)
print(y)

#hsplit
x = np.arange(16.0).reshape(4,4)
print(x)

y = np.hsplit(x,2)
print(y)

#vsplit
x = np.arange(16.0).reshape(4,4)
print(x)

y = np.vsplit(x,2)
print(y)

#tile - Construct an array by repeating A the number of times given by reps.
x = np.array([1,2,3])
y = np.tile(x,2)
print(y)

y = np.tile(x,(2,1))
print(y)

#for 2D
x = np.array([[1,2],[3,4]])
y= np.tile(x,2)
print(y)

y = np.tile(x,(2,1))
print(y)

#repeat
# numpy.repeat(a, repeats, axis=None)
# Repeat each element of an array after themselves
import numpy as np
x = np.array([1,2,3,4])
y = np.repeat(x,3) # = each element is repeated 4 times.
print(y)

# Let us see for 2D array
x_2D = np.array([[1,2],[3,4]])
y_2D = np.repeat(x_2D,3,0) # three times repeat row-wise
print('Axis=0 | row-wise repeatition')
print(y_2D)

y_2D = np.repeat(x_2D,3,1) # three times repeat column-wise
print('Axis=1 | col-wise repeatition')
print(y_2D)

#Different elements different count
y_2D = np.repeat(x_2D,[2,3],0) # three times repeat row-wise
print('Axis=0 | row-wise repeatition | first element repeat 2 & second element repeat 3')
print(y_2D)

"""#delete"""

# delete - Return a new array with sub-arrays along an axis deleted.
# numpy.delete(arr, obj, axis=None).
#

x = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

#Let us delete  second row | index=1
print('Before Deletion')
print(x)
y = np.delete(x,1,0)
print('After Deletion')
print(y)

"""#Concatenate"""

#concatenate
x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6]])
z1 = np.concatenate((x,y),axis=0)
print(z1)

z2 = np.concatenate((x,y.T),axis=1) # if you do not make y.T, it will throw error. As this will add column-wise, then row count for both the array must match.
print(z2)

z3 = np.concatenate((x,y),axis=None) # add all in 1D
print(z3)

"""#copyto"""

x = np.array([[1, 2, 3], [4, 5, 6]])
y = [[4, 5, 6], [7, 8, 9]]
np.copyto(x, y) # copyto(dst,src) y will be copied to x
print(x) # x is now copied from y

"""#shape"""

#shape - returns shape of an array
x_1d = np.array([1,2,3,4,5,6])
x_2d = np.array([[1,2],[3,4],[5,6]])
x_3d = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])

print(x_1d.shape)
print(x_2d.shape)
print(x_3d.shape)

"""#reshape"""

#reshape - Gives a new shape to an array without changing its data.
x_1d = np.array([1,2,3,4,5,6])

#make 2d
print('2x3')
y_2d = np.reshape(x_1d,(2,3))
print(y_2d)

#make 2d with 3x2
print('3x2')
y_2d = np.reshape(x_1d,(3,2))
print(y_2d)
#make 3d
print('1x3x2') # 1 3D array with 3 rows 2 cols
y_2d = np.reshape(x_1d,(1,3,2))
print(y_2d)

print('1x2X3') # 1 3D array with 2 rows 3 cols
y_2d = np.reshape(x_1d,(1,2,3))
print(y_2d)

print('3x1x2') # 3 3D array with 1 rows 2 cols
y_2d = np.reshape(x_1d,(3,1,2))
print(y_2d)

"""#ravel

"""

#np.ravel - Return a contiguous flattened array.
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])
print('a 3D array')
print(x)

#now, using ravel, you can get a flattened array

y = np.ravel(x)
print(y)

"""#flat"""

#np.ndarray.flat - > A 1-D iterator over the array.

x = np.array([[1,2,3],[4,5,6],[7,8,9]]) #2D array

# let us get the 6th element from the array.
y = x.flat[5]
print(y) # this is an 1D iterator.

"""#flatten"""

#numpy.ndarray.flatten -> Return a copy of the array collapsed into one dimension.
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])

y = x.flatten() # y - new array flattened into 1D
print(y)

"""#moveaxis"""

#moveaxis - > Move axes of an array to new positions.
# numpy.moveaxis(a, source, destination)
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])

print('actual array')
print(x)
y = np.moveaxis(x,1,0) # source axis =1 and dest axis = 2
print('after axis movement')
print(y)

#np.swapaxes -> Interchange two axes of an array.
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])
print(x)
y = np.swapaxes(x,1,2)
print(y)

"""#numpy.ndarray.T"""

# numpy.ndarray.T -> View of the transposed array
# this is an attribute

#x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])
x = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(x)
y = x.T
print(y)

print('3D transpose')
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])
print(x)
y = x.T
print(y)

"""#numpy.transpose"""

# numpy.transpose -> returns an array with axes transposed
x = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(x)
y = np.transpose(x)
print(y)

print('3D transpose')
x = np.array([[[1,2,3],[4,5,6],[7,8,9]],[[11,21,31],[41,51,61],[71,81,91]],[[111,211,311],[411,511,611],[711,811,911]]])
print(x)
y = np.transpose(x)
print(y)

"""#np.asarray"""

x = [1,2,3,4]
print(type(x))
y = np.asarray(x)
print(y)
print(type(y))

"""# numpy.squeeze"""

# numpy.squeeze -> numpy.squeeze(a, axis=None)
# Remove axes of length one from array.

x = np.array([[1],[2],[5]])

y = x.squeeze()
print(y)

"""# numpy.expand_dims"""

# numpy.expand_dims
# Expand the shape of an array.
# Insert a new axis that will appear at the axis position in the expanded array shape.
x = np.array([1, 2, 3, 4])

y = np.expand_dims(x,axis=0)
print(y)

y = np.expand_dims(x,axis=1)
print(y)

y = np.expand_dims(x,axis=(0,1))
print(y)

y = np.expand_dims(x,axis=(0,2))
print(y)

y = np.expand_dims(x,axis=(2,0))
print(y)